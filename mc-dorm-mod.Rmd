---
title: "Dormancy in metacommunities"
author: "Nathan Wisnoski"
date: "7/16/2018"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())

library(tidyverse)
library(vegan)
library(progress)
library(viridis)
library(adespatial)
library(igraph)


source("make_landscape.R")
```


### Define model conditions
```{r}
set.seed(47405)

tsteps <- 1000      # Number of time steps in model
dt <- 1    # precision for euler method integration

S <- 20 # Number of species
M <- 10 # Number of sites

```

# Generate the landscape
```{r}
# Generate the landscape randomly, 
# coarse parameter is the spatial structure, bigger values more structure, 
# random is x/y-slope = 0 and coarse ~ 1
# xslope and yslope control directional gradients
landscape <- make.landscape(sites = M, xslope = 0.1, yslope = 0, coarse = 1000, envvars = 1)
coords <- landscape$coords
env <- landscape$env
plot(coords, pch = 20, cex = 2, col = viridis(M)[rank(env)], asp = 1,
     xlim = c(0,100), ylim = c(0,100))


# Generate patch connectivity using dbMEM and visualize
geo.dists <- dist(landscape$coords)
mc.weighted <- listw.candidates(coords, nb = 'pcnm', weights = 'fdown')

plot(coords, pch = 20, cex = 2, col = viridis(M)[rank(env)], asp = 1,
     xlim = c(0,100), ylim = c(0,100))
plot(mc.weighted[[1]], coords, col = adjustcolor("black", alpha.f = 0.1), add = T)


neigh <- mc.weighted$DBEM_PCNM$neighbours
ws <- mc.weighted$DBEM_PCNM$weights

create.edge.list <- function(L){
  edge.list = matrix(NA, nrow = 0, ncol = 2)
  for(i in 1:length(L)){
    for(j in 1:length(L[[i]])){
      edge.list = rbind(edge.list, cbind(i, L[[i]][j]))
    }
  }
  return(edge.list)
}

spatial.edges <- create.edge.list(neigh)
spatial.weights <- create.edge.list(ws)[,-1]

spatial.graph <- graph_from_edgelist(spatial.edges)
E(spatial.graph)$weight <- spatial.weights
plot(spatial.graph)
adj.mat <- as_adjacency_matrix(spatial.graph, attr = "weight")
adj.mat <- as.matrix(adj.mat)
adj.mat
```

### Define parameters
```{r}

# density independent growth
max.growth <- runif(S) + 1
# optimal env conditions
o.comp <- runif(S, min = range(env)[1], max = range(env)[2])
# niche breadths, 
# low nb.spec = more specialists, high nb.spec = more generalists
# low nb.var = most species follow nb.spec, high nb.var = greater mix of species strategies
nb.spec <- 1
nb.var <- 1
sig.comp <- rgamma(S, shape = nb.spec, scale = nb.var)

d.cctradeoff <- function(max.growth, strength = 0.5){
  -max.growth*strength + abs(min(-max.growth*strength))
}
# d <- 0.01

# beverton-holt alpha
a <- 3e-4

# dorm <- 0.3
```

### Metacom Functions
```{r}
R.jx <- function(env.xy, max.growth, o.comp, sig.comp){
  max.growth * exp(-((env.xy - o.comp)^2/(2*sig.comp^2)))
}
  
competition <- function(N,a) {
  return( 1 / ( 1 + a*(sum(N))))
}
  
# disperse <- function(d, N, M){
#   d*((rowSums(N) - N) / (M-1) - N)
# }

disperse <- function(d, adj.mat, N, M){
  
  # calculate dispersing individuals
  dispersers = d * t(N)
  
  # standardize geographic distances, establish barriers via adjacency mat
  connectivity.mat = stdize(as.matrix(geo.dists)) * adj.mat
  
  # disperse individuals 
  dispersers = t(connectivity.mat %*% dispersers)
  return(dispersers)
}

dormancy <- function(dorm, N, D, R.t, comp.t){
  
  # if growth * competition is < 1, shift towards dormancy
  D[which(R.t * comp.t < 1)] <- N[which(R.t * comp.t < 1)] * (dorm)
  N[which(R.t * comp.t < 1)] <- N[which(R.t * comp.t < 1)] * (1-dorm)
  
  # if growth * competition > 1 and there are dormant propagules, reactivate
  N[which(R.t * comp.t > 1 & D.t > 0)] <- D[which(R.t * comp.t > 1 & D.t > 0)] * dorm
  D[which(R.t * comp.t > 1 & D.t > 0)] <- D[which(R.t * comp.t > 1 & D.t > 0)] * (1-dorm)
  
  return(list(N = N, D = D))
}
  
```


### Define model
```{r}
run_sim <- function(d, dorm, env.type){
  
  
  # initialize result array, Species X Sites X Time 
  results.N <- array(NA, c(S, M, tsteps), 
                     dimnames = list(c(paste0("sp",1:S)), c(paste0("site",1:M)), c(1:tsteps)))
  results.D <- array(NA, c(S, M, tsteps),
                     dimnames = list(c(paste0("sp",1:S)), c(paste0("site",1:M)), c(1:tsteps)))
  
  results.N[,,1] <- matrix(rpois(M*S, 1), nrow = S, ncol = M)
  results.D[,,1] <- matrix(0, nrow = S, ncol = M)
  
  res <- matrix(NA, ncol = 5, nrow = 0)
  
  for(yes.dormancy in c(T,F)){
    # perform once with and without dormancy
    
      for(t in 1:(tsteps / dt - 1)){
        # Init or update progress bar
        if(t == 1) pb <- progress_bar$new(total = (tsteps / dt), force = T)
        pb$update(ratio = t/(tsteps / dt))
        
        N.t <- results.N[,,t]
        D.t <- results.D[,,t]
        
        if(env.type != "static"){
          if(env.type == "random"){
            env[,1] <- runif(length(env))
          }
        }
        
        # calculates growth rates for each species (rows) in each site (cols)
        # dimensions = S x M
        R.t <- apply(X = env, MARGIN = 1, FUN = R.jx, max.growth, o.comp, sig.comp)
        
        # calculate competition at this time
        comp.t <- apply(N.t, MARGIN = 2, FUN = competition, a = a)
        
        # growth
        N.t0 <- R.t * N.t * comp.t
        
        if(yes.dormancy){
          dorm.out <- dormancy(dorm, N.t0, D.t, R.t, comp.t)
          N.t0 <- dorm.out$N
          D.t <- dorm.out$D
        }
        
        
        # separate dispersers, then calculate dispersal, and re-add
        
        N.t1 <- N.t0 * (1-d) + disperse(d = d, N = N.t0, M = M, adj.mat = adj.mat)
        
        results.N[,,t+1] <- ifelse(N.t1 > .1, N.t1, 0)
        results.D[,,t+1] <- ifelse(D.t > .1, D.t, 0) 
      }
    
      alpha <- mean(specnumber(t(results.N[,,tsteps] + results.D[,,tsteps])))
      gamma <- sum(rowSums(results.N[,,t] + results.D[,,tsteps]) > 0)
      beta <- gamma / alpha
      beta <- ifelse(is.nan(beta), 0, beta)
      
      # write results to matrix
      res <- rbind(res, cbind(dispersal = d, dormancy = as.numeric(yes.dormancy), alpha = alpha, beta = beta, gamma = gamma))
      
  } 
  
  
  return(res)
  #return(results.N[,,tsteps])
}


```


```{r}
set.seed(47405)
nsims <- 5
# set up dispersal vector
# d.list <- as.list(seq(0,1, by = 0.05))
# d.list <- as.list(c(seq(from = 1, to = 9, by = 4)*1e-9,
#   seq(from = 1, to = 9, by = 3)*1e-8,
#   seq(from = 1, to = 9, by = 4)*1e-7,
#   seq(from = 1, to = 9, by = 3)*1e-6,
#   seq(from = 1, to = 9, by = 4)*1e-5,
#   seq(from = 1, to = 9, by = 3)*1e-4,
#   seq(from = 1, to = 9, by = 4)*1e-3,
#   seq(from = 1, to = 9, by = 4)*1e-2,
#   seq(from = 1, to = 9, by = 4)*1e-1, 1))

d.list <- list(0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 0.5, 1)
#d.list <- list(0)
running.out <- matrix(NA, nrow = 0, ncol = 5)
for(i in 1:nsims){
  print(paste("Simulation",i,"of",nsims,"."))
  # update params
  # density independent growth
  # max.growth <- runif(S) + 1
  max.growth <- 1.2
  # optimal env conditions
  # o.comp <- runif(S, min = range(env)[1], max = range(env)[2])
  o.comp <- 1/S * seq(1:S)
  # niche breadths, 
  # low nb.spec = more specialists, high nb.spec = more generalists
  # low nb.var = most species follow nb.spec, high nb.var = greater mix of species strategies
  nb.spec <- 1
  nb.var <- 2
  
  sig.comp <- seq(.5, S)
  # sig.comp <- rgamma(S, shape = nb.spec, scale = nb.var)
  
  out <- lapply(d.list, FUN = run_sim, env.type = "random", dorm = 0.5)
  # unlist(out)[seq(1:length(unlist(out)))]
  
  for(i in 1:length(out)){
    running.out <- rbind(running.out, out[[i]])
  }
  
  # out <- matrix(unlist(out), ncol = 5, byrow = T)
  # running.out <- rbind(running.out,out)
}



# d.list <- list(0, 0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 0.5, 0.75, 0.9, 1)
# out <- lapply(d.list, FUN = run_sim)
# out <- matrix(unlist(out), ncol = 4, byrow = T)
colnames(running.out) <- c("dispersal", "dormancy", "alpha", "beta", "gamma")
running.out
running.out %>% as_tibble() %>%
  mutate(dormancy = factor(dormancy, levels = c(0,1), labels = c("no", "yes"))) %>% 
  gather(alpha, beta, gamma, -dormancy, key = "scale", value = "diversity") %>%
  group_by(dormancy, dispersal, scale) %>% 
  mutate(mean_div = mean(diversity), se = sd(diversity)/n()) %>%
  ggplot(aes(x = dispersal, y = mean_div, color =  dormancy, shape = scale)) + 
  geom_point(alpha = 0.5, size = 2) + 
  geom_errorbar(aes(ymin = mean_div - se, ymax = mean_div + se)) +
  geom_line(alpha = 0.5) +
  theme_minimal() +
  facet_grid(scale ~ ., scales = "free_y") +
  scale_x_log10(limits = c(1e-9, 1))
```

### plot model output
```{r}
richness.dynamics <- matrix(NA, ncol = M, nrow = tsteps)
colnames(richness.dynamics) <- paste0("site",1:M)

for(t in 1:tsteps){
  richness.dynamics[t,] <- as.vector(specnumber(t(results.N[,,t])))
}

gamma.dynamics <- vector(length = tsteps)
for(t in 1:tsteps){
  gamma.dynamics[t] <- sum(rowSums(results.N[,,t]) > 0)
}

diversity.dynamics <- data.frame(time = seq(1, tsteps), alpha = rowMeans(richness.dynamics), gamma = gamma.dynamics)

diversity.dynamics %>% 
  mutate(beta = gamma/alpha) %>% 
  gather(alpha, beta, gamma, key = "scale", value = "diversity") %>% 
  ggplot(aes(x = time, y = diversity, color = scale)) + 
  geom_point() + 
  geom_line()
```

